<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <title>CS184</title>
        <link href="css/styles.css" rel="stylesheet" />
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
        </script>
        <script type="text/javascript"
            src="http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
    </head>
    <body>
        <!-- Page content-->
        <div class="container">
            <div class="text-center mt-5">
                <h1>Pixel Palooza</h1>
                <p>CS184 Final Project: Spring 2022</p>
                <p class="lead">Nathan Jew, Nicholas Nolte, Cindy Wang, Danny Yu</p>
            </div>
        </div>
        <div class = "container my-5">
            <h3 class = "py-2 text-center">Abstract</h3>
            <p>
                The primary goal of our project was to create a highly generalizable 3D particle simulator.  Many physically accurate particle models of water, fire, and other systems have been made, but often alone in a vacuum.  Our aim was to create a system that could handle many simulation types, as well as the interaction between them.  A tangential aim of this project was related to pixel-art animation.  Pixel-art is difficult, and animating it in a believable way even more so, but the popular indie video game dead cells found a way around this by using a 3D rendering pipeline to create 2D pixel animations.  So in addition to the particle simulation and physics, we attempt to append post-processing steps towards this secondary aim.
            </p>
        </div>
        <div class = "container my-5">
            <h3 class = "py-3 text-center">Technical Approach</h3>
            <h5 class = "py-3 text-center">JSON Parsing and Setup </h5>
            <p>
                We designed our program around taking in JSON files to supply the parameters to define our simulation scenes. Some of the parameters that we want to control, for example, are the number of particle clouds, how many particles are in each, the masses and radii, their colors, and unique collision and attraction properties between different particle types. We can also control parameters for our Marching Cubes algorithm and the locations of primitives such as planes and spheres in the scene. 
            </p>
            <h5 class = "py-3 text-center">The Particle Simulation</h5>
            <p>
                Once the particle start positions and class information has been loaded the physics loop begins.  A key feature of this simulation is the ParticleProperties class, which stores the forces received by particles of its type from other types.  Because we have the potential for many different particle types to be used together, we use this as a way to keep track of the class properties since we cannot hardcode any interactions.  This class maintains pointers to the necessary force functions, and also stores the force with which it operates between any 2 given particles.
            </p>

            <p>
                The reason we have separate Particle and ParticleProperties classes is because there can be hundreds of individual particles, but many of them will share the same base physical properties.  The ParticleProperties class abstracts away the static data which is consistent between particles, while the Particle class itself tracks properties which are unique to each individual particle (such as position and forces).
            </p>
            <figure class="text-center">
                <img src="fws.gif" class="figure-img img-fluid rounded mx-auto" alt="Trulli">
                <figcaption class="figure-caption">Fig.1 - Final simulation of fire water and steam.</figcaption>
            </figure>
            <p>
                Our final demonstration for the project was a simulation containing fire, water, and steam.  First fire appears to blaze from the ground, only to be extinguished by water, before rising up as steam.
            </p>
            <p>
                In describing how this simulation works, we can showcase the inner workings of our simulation system.  Fire was modeled using both an external and internal force.  In our system external forces are a constant force vector applied to the particle, while internal forces occur between particles.  Each piece calculates the forces it receives from other particles, which is dependent on their type.  Fire had an external force downward to simulate gravity, and internal upwards force that came from other particles of the same type.  This internal force was also localized, meaning that only nearby particles affected it, and not all in the simulation.  We added localized forces to reduce computation, as not all forces need to be calculated on every particle.  This was done using box hashing similar to the one used in project 4.  Overall, the force on the fire particles would be:
            </p>
            <p class="text-center py-2">$f = G$ $* <0, -1, 0> +$ $F * \sum_{n} \frac{<0, 1, 0>}{r}$</p>
            <p>
                where $n$ is the set of particles in the same box as the current one and $r$ is the distance between them.  Here $F$ and $G$ are strength constants defined by manual trial and error.
            </p>
<p>
The water in the video starts a large distance above the fire and falls under the external force of gravity.  Our water is modeled very simply, only being affected by particle to particle collisons and a localized internal attraction to approximate surface tension.  One of the main features of water in this simulation is that when it collides with fire, both the fire and water particles turn into steam particles.  This feature of particles transforming into other types is one of the key features we used to make interesting simulations.  
</p>
            <h5 class = "py-3 text-center">Marching Cubes</h5>
            <p>
                Another major feature of our particle simulator was the fact that we wanted to render the particles as a cohesive group with an overall shape, rather than as a bunch of separate points (which is how they exist in code).  In order to do so, we opted to use the Marching Cubes algorithm, which is commonly used for fluid simulation and other similar applications.  The Marching Cubes algorithm operates on a scalar field, which essentially means that it takes in a function where there is some scalar value associated with every 3D point in the world.  Given that function, it can define a surface which separates high valued areas from low valued areas such that high values are "inside" of the mesh, and low values are "outside".
            </p>

            <p>
                For our purposes, this meant that we needed to first define a scalar field which had high values in areas with lots of points, and zero values elsewhere.  For this, we found <a href="https://faculty.cc.gatech.edu/~turk/my_papers/sph_surfaces.pdf">an article</a> with this density-based scalar field, which first computes the density at each point, and then uses that density to determine the strength of the scalar field.
            </p>

            <p class="text-center py-2">$W(r, h) = \sigma\frac{(h^2 - r^2)^3}{h^9}$</p>
            <p class="text-center py-2">$\rho_i = \sum_jm_jW(x_j - x_i, h_j)$</p>
            <p class="text-center py-2">$\phi(x) = \sum_j\frac{m_j}{\rho_j}W(x - x_j, h_j)$</p>

            <p>
                where $W(r, h)$ is a kernel function (inspired by this previous <a href="https://yidingjiang.github.io/cs184sp18_final/">CS184 project</a>) with $\sigma = 0.15$ somewhat arbitrarily, $\rho_i$ is the density for particle $i$ based on its neighbors, and $\phi(x)$ is the final scalar function (taking in input coordinate $x$). We decided that $h$ would be the radius of the particle, but this ended up not being exactly the case in most renderings.
            </p>

            <p>
                Then, when we apply the Marching Cubes algorithm, we get a mesh which separates our particle clusters from the rest of the space, resulting in a dynamic cloud shape which surrounds the particles based on their radii. We adapted <a href="https://www.angelfire.com/linux/myp/MCAdvanced/MCImproved.html">this implementation</a> (specifically the non-recursive approach) for our project, which not only generates a mesh, but also computes vertex normals for smoother shading.  However, in addition to computing a normal for each vertex, we also modified the algorithm so that the scalar field also tracks which particles are most prevalent at each location (in addition to a raw density value for the main algorithm to use).  This allows us to color the triangles based on the particle types present (and even apply different shaders), since there is a single mesh used for the entire particle simulation.  In places where there are multiple particle types present, the colors blend slightly for a smoother appearance.
            </p>

            <h5 class = "py-3 text-center">Particle Averaging</h5>
            <p>
                In general though, we found that often times simulations that replicated more "physical" phenomena benefitted from having more particles to result in a smoother, more full mesh.  However, this of course increased the computational complexity of our physics and density calculations, and often times resulted in collisions which we did not want.  To create more
            </p>
        </div>
        <div class = "container my-5">
            <h3 class = "py-2 text-center">Results</h3>
            <p>Starting from our completed project 4 code, we were able to build a multiclass particle simulator, and produce nearly a dozen distinct animations.  In staying true to our title and goal, we have the final images here rendered with pixelation, accomplishing the toon-like appearance we were aiming for.  One of the most impressive aspects of this project to us was the diversity of what we were able to create.  From protons and electrons at the atomic scale, to a campfire being doused with water at the macroscopic, it is able to capture a wide array of possibilities.  The place with the most room for improvement in all of this is the realism of each individual simulation.  Many projects work to render water, fire, snow and other materials with greater detail than ours.  If we were to continue our projet, our goal would be to combine both the accuracy of those projects and the cross-class interactions.  Nevertheless, we are very happy with the system were able to create, and the particle systems we created out of it.   </p>
<table>
			<tr>
				<td><figure class="text-center">
                <img src="fwsp.gif" class="figure-img img-fluid rounded mx-auto" alt="Trulli">
                <figcaption class="figure-caption">Fig.2 - Fire being extinguished by water and rising as steam.</figcaption>
            </figure></td>
				<td><figure class="text-center">
                <img src="wsc.gif" class="figure-img img-fluid rounded mx-auto" alt="Trulli">
                <figcaption class="figure-caption">Fig.3 - Water colliding with sphere primitives.</figcaption>
            </figure></td>
			</tr>
			<tr>
				<td><figure class="text-center">
                <img src="ztp.gif" class="figure-img img-fluid rounded mx-auto" alt="Trulli">
                <figcaption class="figure-caption">Fig.4 - Particles playing a version of zombie tag.</figcaption>
            </figure></td>
				<td><figure class="text-center">
                <img src="bbp.gif" class="figure-img img-fluid rounded mx-auto" alt="Trulli">
                <figcaption class="figure-caption">Fig.5 - Bullet shatering a block.</figcaption>
            </figure></td>
			</tr>
		</table>
        </div>
        <div class = "container my-5">
            <h3 class = "py-2 text-center">References</h3>
	    <p><a href="https://www.angelfire.com/linux/myp/MCAdvanced/MCImproved.html">Marching Cubes Implementation</a></p>
	    <p><a href="https://yidingjiang.github.io/cs184sp18_final/">CS 184 Project</a></p>
	    <p><a href="https://faculty.cc.gatech.edu/~turk/my_papers/sph_surfaces.pdf">Paper on Surface Reconstruction from Particles</a></p>
        </div>
        <div class = "container my-5">
            <h3 class = "py-2 text-center">Contributions</h3>
            <p><b>Nate</b>: Adapted implementation of marching cubes to work with our system.  Wrote the code to generate the scalar field from the particle positions.  Combined marching cubes with the shader system to allow for altering the appearances of different particle types.</p>
	    <p><b>Nick</b>:Wrote physics simulation based on the project 4 code.  Created parameters for several of the final simulations.</p>
	    <p><b>Cindy</b>:Wrote the cel-shading code.</p>
	    <p><b>Danny</b>:Wrote system to parse particle starting conditions and properties from JSON files.</p>
        </div>
        <!-- Bootstrap core JS
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script> -->
    </body>
</html>
